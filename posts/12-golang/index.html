<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta name="generator" content="Hugo 0.55.6" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>[Golang系列]-Go基础语法之错误处理 | 凡夫俗子的博客</title>
    <meta property="og:title" content="[Golang系列]-Go基础语法之错误处理 - 凡夫俗子的博客">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content="2019-07-10T22:31:16&#43;08:00">
        
        
    <meta property="article:modified_time" content="2019-07-10T22:31:16&#43;08:00">
        
    <meta name="Keywords" content="golang,go语言,go语言笔记,kubernetes,项目管理,python">
    <meta name="description" content="[Golang系列]-Go基础语法之错误处理">
        
    <meta name="author" content="凡夫俗子">
    <meta property="og:url" content="http://gitzh2017.github.io/posts/12-golang/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href="/css/normalize.css">
    
        <link rel="stylesheet" href="/css/prism.css">
    
    <link rel="stylesheet" href="/css/style.css">
    <script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>

    


    
    
</head>

<body>
<header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="http://gitzh2017.github.io/">
                        凡夫俗子的博客
                    </a>
                
                <p class="description">专注于Kubernetes、Python、Go语言(golang)、Linux、项目管理、软件架构</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="http://gitzh2017.github.io/">首页</a>
                    
                    <a  href="http://gitzh2017.github.io/archives/" title="归档">归档</a>
                    
                    <a  href="http://gitzh2017.github.io/about/" title="关于">关于</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>


<div id="body">
    <div class="container">
        <div class="col-group">

            <div class="col-8" id="main">
                <div class="res-cons">
                    <article class="post">
                        <header>
                            <h1 class="post-title">[Golang系列]-Go基础语法之错误处理</h1>
                        </header>
                        <date class="post-meta meta-date">
                            2019年7月10日
                        </date>
                        
                        
                        
                        <div class="clear">
                            <div class="toc-article">
                                <div class="toc-title">文章目录</div>
                                <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#error-接口">error 接口</a></li>
<li><a href="#自定义-error">自定义 error</a></li>
<li><a href="#存在的问题">存在的问题</a></li>
<li><a href="#解决问题">解决问题</a></li>
<li><a href="#推荐的方案">推荐的方案</a></li>
<li><a href="#小结">小结</a></li>
</ul></li>
</ul>
</nav>
                            </div>
                        </div>
                        
                        <div class="post-content">
                            <p>对于Go语言（golang）的错误设计，相信很多人已经体验过了，它是通过返回值的方式，来强迫调用者对错误进行处理，要么你忽略，要么你处理（处理也可以是继续返回给调用者），对于golang这种设计方式，我们会在代码中写大量的if判断，以便做出决定。</p>

<pre><code class="language-go">func main() {
	conent,err:=ioutil.ReadFile(&quot;filepath&quot;)
	if err !=nil{
		//错误处理
	}else {
		fmt.Println(string(conent))
	}
}
</code></pre>

<p>这类代码，在我们编码中是非常的，大部分情况下<code>error</code>都是<code>nil</code>，也就是没有任何错误，但是<code>非nil</code>的时候，意味着错误就出现了，我们需要对他进行处理。</p>

<h2 id="error-接口">error 接口</h2>

<p><code>error</code>其实一个<code>接口</code>，内置的，我们看下它的定义</p>

<pre><code class="language-go">// The error built-in interface type is the conventional interface for
// representing an error condition, with the nil value representing no error.
type error interface {
	Error() string
}
</code></pre>

<p>它只有一个方法 <code>Error</code>，只要实现了这个方法，就是实现了error。现在我们自己定义一个错误试试。</p>

<pre><code class="language-go">type fileError struct {
}

func (fe *fileError) Error() string {
	return &quot;文件错误&quot;
}
</code></pre>

<h2 id="自定义-error">自定义 error</h2>

<p>自定义了一个<code>fileError</code>类型，实现了error接口。现在测试下看看效果。</p>

<pre><code class="language-go">func main() {
	conent, err := openFile()
	if err != nil {
		fmt.Println(err)
	} else {
		fmt.Println(string(conent))
	}
}

//只是模拟一个错误
func openFile() ([]byte, error) {
	return nil, &amp;fileError{}
}
</code></pre>

<p>我们运行模拟的代码，可以看到<code>文件错误</code>的通知。</p>

<p>在实际的使用过程中，我们可能遇到很多错误，他们的区别是错误信息不一样，一种做法是每种错误都类似上面一样定义一个错误类型，但是这样太麻烦了。我们发现Error返回的其实是个字符串，我们可以修改下，让这个字符串可以设置就可以了。</p>

<pre><code class="language-go">type fileError struct {
	s string
}

func (fe *fileError) Error() string {
	return fe.s
}
</code></pre>

<p>恩，这样改造后，我们就可以在声明<code>fileError</code>的时候，设置好要提示的错误文字，就可以满足我们不同的需要了。</p>

<pre><code class="language-go">//只是模拟一个错误
func openFile() ([]byte, error) {
	return nil, &amp;fileError{&quot;文件错误，自定义&quot;}
}
</code></pre>

<p>恩，可以了，已经达到了我们的目的。现在我们可以把它变的更通用一些，比如修改<code>fileError</code>的名字，再创建一个辅助函数，便于我们创建不同的错误类型。</p>

<pre><code class="language-go">func New(text string) error {
	return &amp;errorString{text}
}

type errorString struct {
	s string
}

func (e *errorString) Error() string {
	return e.s
}
</code></pre>

<p>变成以上这样，我们就可以通过<code>New</code>函数，辅助我们创建不同的错误了，这其实就是我们经常用到的<code>errors.New</code>函数，被我们一步步剖析演化而来，现在大家对Go语言(golang)内置的错误error有了一个清晰的认知了。</p>

<h2 id="存在的问题">存在的问题</h2>

<p>虽然Go语言对错误的设计非常简洁，但是对于我们开发者来说，很明显是不足的，比如我们需要知道出错的更多信息，在什么文件的，哪一行代码？只有这样我们才更容易的定位问题。</p>

<p>还有比如，我们想对返回的error附加更多的信息后再返回，比如以上的例子，我们怎么做呢？我们只能先通过Error方法，取出原来的错误信息，然后自己再拼接，再使用errors.New函数生成新错误返回。</p>

<p>如果我们以前做过java开发，我们知道Java的异常是可以嵌套的，也就是说，通过这个，我们很容易知道错误的根本原因，因为Java的异常，是一层层的嵌套返回的，不管中间经历了多少包装，我们可以通过<code>cause</code>找到根本错误的原因。</p>

<h2 id="解决问题">解决问题</h2>

<p>如果要解决以上的问题，那么首先我们必须再继续扩充我们的<code>errorString</code>，再增加一些字段来存储更多的信息。比如我们要记录堆栈信息。</p>

<pre><code class="language-go">type stack []uintptr
type errorString struct {
	s string
	*stack
}
</code></pre>

<p>有了存储堆栈信息的<code>stack</code>字段，我们在生成错误的时候，就可以把调用的堆栈信息存储在这个字段里。</p>

<pre><code class="language-go">func callers() *stack {
	const depth = 32
	var pcs [depth]uintptr
	n := runtime.Callers(3, pcs[:])
	var st stack = pcs[0:n]
	return &amp;st
}

func New(text string) error {
	return &amp;errorString{
		s:   text,
		stack: callers(),
	}
}
</code></pre>

<p>完美解决，现在如果再解决，对现有的错误附加一些信息的问题呢？相信大家应该有思路了。</p>

<pre><code class="language-go">type withMessage struct {
	cause error
	msg   string
}

func WithMessage(err error, message string) error {
	if err == nil {
		return nil
	}
	return &amp;withMessage{
		cause: err,
		msg:   message,
	}
}
</code></pre>

<p>使用<code>WithMessage</code>函数，对原来的error包装下，就可以生成一个新的带有包装信息的错误了。</p>

<h2 id="推荐的方案">推荐的方案</h2>

<p>以上我们在解决问题是，采取的方法是不是比较熟悉？尤其是看源代码，没错，这就是<code>github.com/pkg/errors</code>这个错误处理库的源代码。</p>

<p>因为Go语言提供的错误太简单了，以至于简单的我们无法更好的处理问题，甚至不能为我们处理错误，提供更有用的信息，所以诞生了很多对错误处理的库，<code>github.com/pkg/errors</code>是比较简洁的一样，并且功能非常强大，受到了大量开发者的欢迎，使用者很多。</p>

<p>它的使用非常简单，如果我们要新生成一个错误，可以使用<code>New</code>函数,生成的错误，自带调用堆栈信息。</p>

<pre><code class="language-go">func New(message string) error
</code></pre>

<p>如果有一个现成的<code>error</code>，我们需要对他进行再次包装处理，这时候有三个函数可以选择。</p>

<pre><code class="language-go">//只附加新的信息
func WithMessage(err error, message string) error

//只附加调用堆栈信息
func WithStack(err error) error

//同时附加堆栈和信息
func Wrap(err error, message string) error
</code></pre>

<p>其实上面的包装，很类似于Java的异常包装，被包装的<code>error</code>，其实就是<code>Cause</code>,在前面的章节提到错误的根本原因，就是这个<code>Cause</code>。所以这个错误处理库为我们提供了<code>Cause</code>函数让我们可以获得最根本的错误原因。</p>

<pre><code class="language-go">func Cause(err error) error {
	type causer interface {
		Cause() error
	}

	for err != nil {
		cause, ok := err.(causer)
		if !ok {
			break
		}
		err = cause.Cause()
	}
	return err
}
</code></pre>

<p>使用<code>for</code>循环一直找到最根本（最底层）的那个<code>error</code>。</p>

<p>以上的错误我们都包装好了，也收集好了，那么怎么把他们里面存储的堆栈、错误原因等这些信息打印出来呢？其实，这个错误处理库的错误类型，都实现了<code>Formatter</code>接口，我们可以通过<code>fmt.Printf</code>函数输出对应的错误信息。</p>

<pre><code>%s,%v //功能一样，输出错误信息，不包含堆栈
%q //输出的错误信息带引号，不包含堆栈
%+v //输出错误信息和堆栈
</code></pre>

<p>以上如果有循环包装错误类型的话，会递归的把这些错误都会输出。</p>

<h2 id="小结">小结</h2>

<p>通过使用这个 <code>github.com/pkg/errors</code> 错误库，我们可以收集更多的信息，可以让我们更容易的定位问题。</p>

<p>我们收集的这些信息不止可以输出到控制台，也可以当做日志，使用输出到相应的<code>Log</code>日志里，便于分析问题。</p>

<p>据说这个库，会被加入到Golang 标准 SDK 里，期待着，如果加入的话，应该就是补充现在标准库里的<code>errors</code> 这个package了。</p>
                        </div>

                        


                        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/00-django/">00 Django</a></li>
        
        <li><a href="/02-elasticsearch/">02 Elasticsearch</a></li>
        
        <li><a href="/01-elasticsearch/">[Elasticsearch系列]-Elasticsearch Operator快速部署Elasticsearch集群</a></li>
        
        <li><a href="/00-elasticsearch/">[Elasticsearch系列]-概述</a></li>
        
        <li><a href="/posts/11-golang/">[Golang系列]-Go基础语法之指针</a></li>
        
    </ul>
</div>


                        <div class="post-meta meta-tags">
                            
                            没有标签
                            
                        </div>
                    </article>
                    
    

    
    
                </div>
            </div>
            <div id="secondary">
    <section class="widget">
        <form id="search" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="http://gitzh2017.github.io/">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="http://gitzh2017.github.io/posts/12-golang/" title="[Golang系列]-Go基础语法之错误处理">[Golang系列]-Go基础语法之错误处理</a>
    </li>
    
    <li>
        <a href="http://gitzh2017.github.io/posts/00-django/" title="00 Django">00 Django</a>
    </li>
    
    <li>
        <a href="http://gitzh2017.github.io/posts/11-golang/" title="[Golang系列]-Go基础语法之指针">[Golang系列]-Go基础语法之指针</a>
    </li>
    
    <li>
        <a href="http://gitzh2017.github.io/posts/10-golang/" title="[Golang系列]-Go基础语法之map">[Golang系列]-Go基础语法之map</a>
    </li>
    
    <li>
        <a href="http://gitzh2017.github.io/posts/09-golang/" title="[Golang系列]-Go基础语法之切片">[Golang系列]-Go基础语法之切片</a>
    </li>
    
    <li>
        <a href="http://gitzh2017.github.io/posts/08-golang/" title="[Golang系列]-Go基础语法之数组">[Golang系列]-Go基础语法之数组</a>
    </li>
    
    <li>
        <a href="http://gitzh2017.github.io/posts/07-golang/" title="[Golang系列]-Go基础语法之函数">[Golang系列]-Go基础语法之函数</a>
    </li>
    
    <li>
        <a href="http://gitzh2017.github.io/posts/06-golang/" title="[Golang系列]-Go基础语法之流程控制">[Golang系列]-Go基础语法之流程控制</a>
    </li>
    
    <li>
        <a href="http://gitzh2017.github.io/posts/05-golang/" title="[Golang系列]-Go基础语法之运算符">[Golang系列]-Go基础语法之运算符</a>
    </li>
    
    <li>
        <a href="http://gitzh2017.github.io/posts/04-golang/" title="[Golang系列]-Go基础语法之基础数据类型">[Golang系列]-Go基础语法之基础数据类型</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">分类</h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title">标签</h3>
<div class="tagcloud">
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="http://gitzh2017.github.io/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
        </div>
    </div>
</div>
<footer id="footer">
    <div class="container">
        &copy; 2019 <a href="http://gitzh2017.github.io/">凡夫俗子的博客 By 凡夫俗子</a>.
        Powered by <a rel="nofollow noreferer noopener" href="https://gohugo.io" target="_blank">Hugo</a>.
        <a href="https://www.flysnow.org/" target="_blank">Theme</a> based on <a href="https://github.com/rujews/maupassant-hugo" target="_blank">maupassant</a>.
        
    </div>
</footer>


    <script type="text/javascript">
    
    (function(){
        $("pre code").parent().addClass("line-numbers")
    }())

    window.MathJax = {
        tex2jax: {
            inlineMath: [ ['$','$'] ],
            processEscapes: true
        }
    };
    </script>
    <script type="text/javascript" src="/js/prism.js" async="true"></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src="/js/totop.js?v=0.0.0" async=""></script>






</body>
</html>
