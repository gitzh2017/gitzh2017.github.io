<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta name="generator" content="Hugo 0.55.6" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>【Golang系列】Go语言环境搭建 | 凡夫俗子的博客</title>
    <meta property="og:title" content="【Golang系列】Go语言环境搭建 - 凡夫俗子的博客">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content="2019-06-21T16:20:51&#43;08:00">
        
        
    <meta property="article:modified_time" content="2019-06-21T16:20:51&#43;08:00">
        
    <meta name="Keywords" content="golang,go语言,go语言笔记,kubernetes,项目管理,python">
    <meta name="description" content="【Golang系列】Go语言环境搭建">
        
    <meta name="author" content="凡夫俗子">
    <meta property="og:url" content="http://gitzh2017.github.io/posts/01-golang/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href="/css/normalize.css">
    
        <link rel="stylesheet" href="/css/prism.css">
    
    <link rel="stylesheet" href="/css/style.css">
    <script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>

    


    
    
</head>

<body>
<header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="http://gitzh2017.github.io/">
                        凡夫俗子的博客
                    </a>
                
                <p class="description">专注于Kubernetes、Python、Go语言(golang)、Linux、项目管理、软件架构</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="http://gitzh2017.github.io/">首页</a>
                    
                    <a  href="http://gitzh2017.github.io/archives/" title="归档">归档</a>
                    
                    <a  href="http://gitzh2017.github.io/about/" title="关于">关于</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>


<div id="body">
    <div class="container">
        <div class="col-group">

            <div class="col-8" id="main">
                <div class="res-cons">
                    <article class="post">
                        <header>
                            <h1 class="post-title">【Golang系列】Go语言环境搭建</h1>
                        </header>
                        <date class="post-meta meta-date">
                            2019年6月21日
                        </date>
                        
                        
                        
                        <div class="post-content">
                            

<p>[TOC]</p>

<h1 id="golang-下载">Golang 下载</h1>

<p>要搭建Go语言开发环境，我们第一步要下载go的开发工具包，目前最新稳定版本是v1.9，Go1.9增加了一些新特性，我这里有一篇讲 <a href="http://www.flysnow.org/2017/08/26/go-1-9-type-alias.html">Go语言 | Go 1.9 新特性 Type Alias详解</a> 的，大家可以参考。Go为我们所熟知的所有平台架构提供了开发工具包，比如我们熟知的Linux、Mac和Windows，其他的还有FreeBSD等。</p>

<!-- more -->

<p>我们可以根据自己的机器操作系统选择相应的开发工具包，比如你的是Windows 64位的，就选择windows-amd64的工具包；是Linux 32位的就选择linux-386的工具包。可以自己查看下自己的操作系统，然后选择，Mac的现在都是64位的，直接选择就可以了。</p>

<p>开发工具包又分为安装版和压缩版。安装版是Mac和Windows特有的，他们的名字类似于：</p>

<ul>
<li>go1.9.darwin-amd64.pkg</li>
<li>go1.9.windows-386.msi</li>
<li>go1.9.windows-amd64.msi</li>
</ul>

<p>安装版，顾名思义，双击打开会出现安装向导，让你选择安装的路径，帮你设置好环境比安康等信息，比较省事方便一些。</p>

<p>压缩版的就是一个压缩文件，可以解压得到里面的内容，他们的名字类似于：</p>

<ul>
<li>go1.9.darwin-amd64.tar.gz</li>
<li>go1.9.linux-386.tar.gz</li>
<li>go1.9.linux-amd64.tar.gz</li>
<li>go1.9.windows-386.zip</li>
<li>go1.9.windows-amd64.zip</li>
</ul>

<p>压缩版我们下载后需要解压，然后自己移动到要存放的路径下，并且配置环境变量等信息，相比安装版来说，比较复杂一些，手动配置的比较多。</p>

<p>根据自己的操作系统选择后，就可以下载开发工具包了，Go语言的官方下载地址是 <a href="https://golang.org/dl/">https://golang.org/dl/</a> 可以打开选择版本下载，如果该页面打不开，或者打开了下载不了，可以使用镜像网站 <a href="http://mirrors.flysnow.org/">http://mirrors.flysnow.org/</a> ,打开后搜索或者找到Golang，选择相应的版本下载，这个镜像网站会同步更新官方版本，基本上都是最新版，可以放心使用。</p>

<h1 id="golang-安装">Golang 安装</h1>

<h2 id="linux下安装">Linux下安装</h2>

<p>我们以Ubuntu 64位为例进行演示，CentOS等其他Linux发行版大同小异。</p>

<p>下载go1.9.linux-amd64.tar.gz后，进行解压，你可以采用自带的解压软件解压，如果没有可以在终端行使用tar命令行工具解压，我们这里选择的安装目录是<code>/usr/local/go</code>,可以使用如下命令：</p>

<pre><code class="language-bash">tar -C /usr/local -xzf go1.9.linux-amd64.tar.gz
</code></pre>

<p>如果提示没有权限，在最前面加上<code>sudo</code>以root用户的身份运行。运行后，在<code>／usr/local/</code>下就可以看到go目录了。如果是自己用软件解压的，可以拷贝到/usr/local/go下，但是要保证你的go文件夹下是bin、src、doc等目录，不要go文件夹下又是一个go文件夹，这样就双重嵌套了。</p>

<p>然后就要配置环境变量了，Linux下又两个文件可以配置，其中<code>/etc/profile</code>是针对所有用户都有效的；<code>$HOME/.profile</code>是针对当前用户有效的，可以根据自己的情况选择。</p>

<p>针对所有用户的需要重启电脑才可以生效；针对当前用户的，在终端里使用source命令加载这个<code>$HOME/.profile</code>即可生效。</p>

<pre><code class="language-bash">source ~/.profile
</code></pre>

<p>使用文本编辑器比如VIM编辑他们中的任意一个文件，在文件的末尾添加如下配置保存即可：</p>

<pre><code class="language-bash">export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
</code></pre>

<p>其中GOROOT环境变量表示我们GO的安装目录，这样其他软件比如我们使用的Go开发IDE就可以自动的找到我们的Go安装目录，达到自动配置Go SDK的目的。</p>

<p>第二句配置是把<code>/usr/local/go/bin</code>这个目录加入到环境变量PATH里，这样我可以在终端里直接输入go等常用命令使用了，而不用再加上<code>/usr/local/go/bin</code>这一串绝对路径，更简洁方便。</p>

<p>以上配置好之后，我们打开终端，属于如下命令，就可以看到go的版本等信息了。</p>

<pre><code class="language-bash">➜  ~ go version
go version go1.9 linux/amd64
</code></pre>

<p>这就说明我们已经安装go成功了，如果提示go这个命令找不到，说明我们配置还不对，主要在PATH这个环境变量，仔细检查，直到可以正常输出为止。</p>

<h2 id="mac下安装">Mac下安装</h2>

<p>Mac分为压缩版和安装版，他们都是64位的。压缩版和Linux的大同小异，因为Mac和Linux都是基于Unix，终端这一块基本上是相同的。</p>

<p>压缩版解压后，就可以和Linux一样放到一个目录下，这里也以<code>/usr/local/go/</code>为例。在配置环境变量的时候，针对所有用户和Linux是一样的，都是<code>/etc/profile</code>这个文件；针对当前用户，Mac下是<code>$HOME/.bash_profile</code>，其他配置都一样，包括编辑sudo权限和生效方式，最后在终端里测试：</p>

<pre><code class="language-bash">➜  ~ go version
go version go1.9 darwin/amd64
</code></pre>

<p>Mac安装版下载后双击可以看到安装界面，按照提示一步步选择操作即可。安装版默认安装目录是<code>/usr/local/go</code>，并且也会自动的把<code>/usr/local/go/bin</code>目录加入到PATH环境变量中，重新打开一个终端，就可以使用<code>go version</code>进行测试了，更快捷方便一些。</p>

<h2 id="windows下安装">Windows下安装</h2>

<p>Windows也有压缩版和安装版，又分为32和64位以供选择，不过目前大家都是64位，选择这个更好一些。</p>

<p>Window的压缩版是一个ZIP压缩包，下载后使用winrar等软件就可以解压，解压后要选择一个存放目录，比如<code>c:\Go</code>下，这个<code>c:\Go</code>就是Go的安装目录了，他里面有bin、src、doc等目录。</p>

<p>然后就是环境变量的配置，Window也和Linux一样分为针对所有用户的系统变量，和针对当前用户的用户变量设置，可以自行选择，比如系统变量，针对所有用户都有效。</p>

<p>以Window 7为例，右击我的电脑-&gt;属性会打开系统控制面板，然后在左侧找到<code>高级系统设置</code>点击打开，会在弹出的界面最下方看到<code>环境变量</code>按钮，点击它，就可以看到环境变量配置界面了。上半部分是用户变量配置，下半部分是系统变量配置。</p>

<p>我们在系统变量里点击新建，变量名输入GOROOT，变量值是我们刚刚安装的go路径<code>c:\Go</code>,这样就配置好了GO目录的安装路径了。</p>

<p>然后修改PATH系统变量，在变量值里添加<code>%%GOROOT\bin</code>路径，和其他PATH变量以;(分号，Linux下是冒号)分割即可。这样我们就可以在CMD里直接输入go命令使用了。</p>

<p>打开我们的终端，输入<code>go version</code>测试下，好了的话就可以看到输出的信息了。</p>

<p>Window的安装版相比来说就比较简单一些，双击就可以按照提示一步步安装，默认安装路径是<code>c:\Go</code>,并且会配置好PATH环境变量，可以直接打开CMD终端使用。</p>

<h1 id="golang-配置">Golang 配置</h1>

<h2 id="设置工作目录">设置工作目录</h2>

<p>工作目录就是我们用来存放开发的源代码的地方，对应的也是Go里的GOPATH这个环境变量。这个环境变量指定之后，我们编译源代码等生成的文件都会放到这个目录下，GOPATH环境变量的配置参考上面的安装Go，配置到<code>/etc/profile</code>或者Windows下的系统变量里。</p>

<p>这个工作目录我们可以根据自己的设置指定，比如我的Mac在$HOME/code/go下，Window的可以放到d:\code\go下等。该目录下有3个子目录，他们分别是：</p>

<pre><code class="language-bash">.
├── bin
├── pkg
└── src
</code></pre>

<ul>
<li>bin文件夹存放<code>go install</code>命名生成的可执行文件，可以把GOPATH/bin路径加入到PATH环境变量里，就和我们上面配置的GOPATH/bin路径加入到PATH环境变量里，就和我们上面配置的GOROOT/bin一样，这样就可以直接在终端里使用我们go开发生成的程序了。</li>
<li>pkg文件夹是存在go编译生成的文件。</li>
<li>src存放的是我们的go源代码，不同工程项目的代码以包名区分。</li>
</ul>

<h2 id="go项目工程结构">go项目工程结构</h2>

<p>配置好工作目录后，就可以编码开发了，在这之前，我们看下go的通用项目结构,这里的结构主要是源代码相应地资源文件存放目录结构。</p>

<p>我们知道源代码都是存放在GOPATH的src目录下，那么多个多个项目的时候，怎么区分呢？答案是通过包，使用包来组织我们的项目目录结构。有过java开发的都知道，使用包进行组织代码，包以网站域名开头就不会有重复，比如我的个人网站是<code>flysnow.org</code>,我就可以以·flysnow.org·的名字创建一个文件夹，我自己的go项目都放在这个文件夹里，这样就不会和其他人的项目冲突，包名也是唯一的。</p>

<p>如果没有个人域名，现在流行的做法是使用你个人的github.com，因为每个人的是唯一的，所以也不会有重复。</p>

<pre><code class="language-bash">src
├── flysnow.org
├── github.com
├── golang.org
├── gopkg.in
├── qiniupkg.com
└── sourcegraph.com
</code></pre>

<p>如上，src目录下跟着一个个域名命名的文件夹。再以github.com文件夹为例，它里面又是以github用户名命名的文件夹，用于存储属于这个github用户编写的go源代码。</p>

<pre><code class="language-bash">src/github.com/spf13
├── afero
├── cast
├── cobra
├── fsync
├── hugo
├── jwalterweatherman
├── nitro
├── pflag
└── viper
</code></pre>

<p>那么我们如何引用一个包呢，也就是go里面的import。其实非常简单，通过包路径，包路径就是从src目录开始，逐级文件夹的名字用<code>/</code>连起来就是我们需要的包名，比如：</p>

<pre><code class="language-go">import (
	&quot;github.com/spf13/hugo/commands&quot;
)
</code></pre>

<h1 id="golang-hello-world">Golang Hello world</h1>

<p>都准备好了，让我们创建一个<code>hello</code>项目，测试一下。我的项目的路径为<code>src/flysnow.org/hello/</code>。</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
)

func main() {
	fmt.Println(&quot;Hello World&quot;)
}
</code></pre>

<p>Go版Hello World非常简单。在<code>src/flysnow.org/hello/</code>目录下运行<code>go run main.go</code>命令就可以看到打印的输出<code>Hello World</code>，下面解释下这段代码。</p>

<p>1.package 是一个关键字，定义一个包，和Java里的package一样，也是模块化的关键。 2. main包是一个特殊的包名，它表示当前是一个可执行程序，而不是一个库。 3. import 也是一个关键字，表示要引入的包，和Java的import关键字一样，引入后才可以使用它。 4. fmt是一个包名，这里表示要引入fmt这个包，这样我们就可以使用它的函数了。 5. main函数是主函数，表示程序执行的入口，Java也有同名函数，但是多了一个String[]类型的参数。 6. Println是fmt包里的函数，和Java里的system.out.println作用类似，这里输出一段文字。</p>

<p>整段代码非常简洁，关键字、函数、包等和Java非常相似，不过注意，go是不需要以;(分号)结尾的。</p>

<h1 id="golang-编译-安装程序">Golang 编译&amp;安装程序</h1>

<h2 id="跨平台编译">跨平台编译</h2>

<p>以前运行和安装，都是默认根据我们当前的机器生成的可执行文件，比如你的是Linux 64位，就会生成Linux 64位下的可执行文件，比如我的Mac，可以使用<code>go env</code>查看编译环境,以下截取重要的部分。</p>

<pre><code class="language-bash">➜  ~ go env
GOARCH=&quot;amd64&quot;
GOEXE=&quot;&quot;
GOHOSTARCH=&quot;amd64&quot;
GOHOSTOS=&quot;darwin&quot;
GOOS=&quot;darwin&quot;
GOROOT=&quot;/usr/local/go&quot;
GOTOOLDIR=&quot;/usr/local/go/pkg/tool/darwin_amd64&quot;
</code></pre>

<p>注意里面两个重要的环境变量<code>GOOS</code>和<code>GOARCH</code>,其中<code>GOOS</code>指的是目标操作系统，它的可用值为：</p>

<ol>
<li>darwin</li>
<li>freebsd</li>
<li>linux</li>
<li>windows</li>
<li>android</li>
<li>dragonfly</li>
<li>netbsd</li>
<li>openbsd</li>
<li>plan9</li>
<li>solaris</li>
</ol>

<p>一共支持10中操作系统。<code>GOARCH</code>指的是目标处理器的架构，目前支持的有：</p>

<ol>
<li>arm</li>
<li>arm64</li>
<li>386</li>
<li>amd64</li>
<li>ppc64</li>
<li>ppc64le</li>
<li>mips64</li>
<li>mips64le</li>
<li>s390x</li>
</ol>

<p>一共支持9中处理器的架构，<code>GOOS</code>和<code>GOARCH</code>组合起来，支持生成的可执行程序种类很多，具体组合参考<a href="https://golang.org/doc/install/source#environment">https://golang.org/doc/install/source#environment</a>。如果我们要生成不同平台架构的可执行程序，只要改变这两个环境变量就可以了，比如要生成linux 64位的程序，命令如下：</p>

<pre><code class="language-bash">GOOS=linux GOARCH=amd64 go build flysnow.org/hello
</code></pre>

<p>前面两个赋值，是更改环境变量，这样的好处是只针对本次运行有效，不会更改我们默认的配置。</p>

<h2 id="安装程序">安装程序</h2>

<p>安装的意思，就是生成可执行的程序，以供我们使用，为此go为我们提供了很方便的install命令，可以快速的把我们的程序安装到$GOAPTH/bin目录下。</p>

<pre><code class="language-bash">go install flysnow.org/hello
</code></pre>

<p>打开终端，运行上面的命令即可，install后跟全路径的包名。 然后我们在终端里运行hello就看到打印的Hello World了。</p>

<pre><code class="language-bash">➜  ~ hello
Hell World
</code></pre>

<h1 id="golang-常用命令">Golang 常用命令</h1>

<p>在Go语言中，我们很多操作都是通过go命令进行的，比如我们要执行go文件的编译，就需要使用go build命令，除了build命令之外，还有很多常用的命令，这一次我们就统一进行介绍，对常用命令有一个了解，这样我们就可以更容易的开发我们的Go程序了。</p>

<h2 id="go-开发工具概览">Go 开发工具概览</h2>

<p><code>go</code>这个工具，别看名字短小，其实非常强大，是一个强大的开发工具，让我们打开终端，看看这个工具有哪些能力。</p>

<pre><code class="language-bash">➜  ~ go
Go is a tool for managing Go source code.

Usage:

	go command [arguments]

The commands are:

	build       compile packages and dependencies
	clean       remove object files
	doc         show documentation for package or symbol
	env         print Go environment information
	bug         start a bug report
	fix         run go tool fix on packages
	fmt         run gofmt on package sources
	generate    generate Go files by processing source
	get         download and install packages and dependencies
	install     compile and install packages and dependencies
	list        list packages
	run         compile and run Go program
	test        test packages
	tool        run specified go tool
	version     print Go version
	vet         run go tool vet on packages

Use &quot;go help [command]&quot; for more information about a command.

Additional help topics:

	c           calling between Go and C
	buildmode   description of build modes
	filetype    file types
	gopath      GOPATH environment variable
	environment environment variables
	importpath  import path syntax
	packages    description of package lists
	testflag    description of testing flags
	testfunc    description of testing functions

Use &quot;go help [topic]&quot; for more information about that topic.
</code></pre>

<p>可以发现，go支持的子命令很多，同时还支持查看一些【主题】。我们可以使用<code>go help [command]</code>或者<code>go help [topic]</code>查看一些命令的使用帮助，或者关于某个主题的信息。大部分go的命令，都是接受一个全路径的包名作为参数，比如我们经常用的<code>go build</code>。</p>

<h2 id="go-build">go build</h2>

<p><code>go build</code>,是我们非常常用的命令，它可以启动编译，把我们的包和相关的依赖编译成一个可执行的文件。</p>

<pre><code class="language-bash">usage: go build [-o output] [-i] [build flags] [packages]
</code></pre>

<p><code>go build</code>的使用比较简洁，所有的参数都可以忽略，直到只有<code>go build</code>，这个时候意味着使用当前目录进行编译，下面的几条命令是等价的：</p>

<pre><code class="language-bash">go build

go build .

go build hello.go
</code></pre>

<p>以上这三种写法，都是使用当前目录编译的意思。因为我们忽略了<code>packages</code>,所以自然就使用当前目录进行编译了。从这里我们也可以推测出，<code>go build</code>本质上需要的是一个路径，让编译器可以找到哪些需要编译的go文件。<code>packages</code>其实是一个相对路径，是相对于我们定义的<code>GOROOT</code>和<code>GOPATH</code>这两个环境变量的，所以有了<code>packages</code>这个参数后，<code>go build</code>就可以知道哪些需要编译的go文件了。</p>

<pre><code class="language-bash">go build flysnow.org/tools
</code></pre>

<p>这种方式是指定包的方式，这样会明确的编译我们这个包。当然我们也可以使用通配符。</p>

<pre><code class="language-bash">go build flysnow.org/tools/...
</code></pre>

<p>3个点表示匹配所有字符串，这样<code>go build</code>就会编译tools目录下的所有包。</p>

<p>讲到<code>go build</code>编译，不能不提跨平台编译，Go提供了编译链工具，可以让我们在任何一个开发平台上，编译出其他平台的可执行文件。</p>

<p>默认情况下，都是根据我们当前的机器生成的可执行文件，比如你的是Linux 64位，就会生成Linux 64位下的可执行文件，比如我的Mac，可以使用go env查看编译环境,以下截取重要的部分。</p>

<pre><code class="language-bash">➜  ~ go env
GOARCH=&quot;amd64&quot;
GOEXE=&quot;&quot;
GOHOSTARCH=&quot;amd64&quot;
GOHOSTOS=&quot;darwin&quot;
GOOS=&quot;darwin&quot;
GOROOT=&quot;/usr/local/go&quot;
GOTOOLDIR=&quot;/usr/local/go/pkg/tool/darwin_amd64&quot;
</code></pre>

<p>注意里面两个重要的环境变量GOOS和GOARCH,其中GOOS指的是目标操作系统，它的可用值为：</p>

<ol>
<li>darwin</li>
<li>freebsd</li>
<li>linux</li>
<li>windows</li>
<li>android</li>
<li>dragonfly</li>
<li>netbsd</li>
<li>openbsd</li>
<li>plan9</li>
<li>solaris</li>
</ol>

<p>一共支持10中操作系统。GOARCH指的是目标处理器的架构，目前支持的有：</p>

<ol>
<li>arm</li>
<li>arm64</li>
<li>386</li>
<li>amd64</li>
<li>ppc64</li>
<li>ppc64le</li>
<li>mips64</li>
<li>mips64le</li>
<li>s390x</li>
</ol>

<p>一共支持9中处理器的架构，GOOS和GOARCH组合起来，支持生成的可执行程序种类很多，具体组合参考<a href="https://golang.org/doc/install/source#environment">https://golang.org/doc/install/source#environment</a>。如果我们要生成不同平台架构的可执行程序，只要改变这两个环境变量就可以了，比如要生成linux 64位的程序，命令如下：</p>

<pre><code class="language-bash">GOOS=linux GOARCH=amd64 go build flysnow.org/hello
</code></pre>

<p>前面两个赋值，是更改环境变量，这样的好处是只针对本次运行有效，不会更改我们默认的配置。</p>

<p>以上这些用法差不多够我们用的了，更多关于<code>go build</code>的用户可以通过以下命令查看:</p>

<pre><code class="language-bash">go help build
</code></pre>

<h2 id="go-clean">go clean</h2>

<p>在我们使用<code>go build</code>编译的时候，会产生编译生成的文件，尤其是在我们签入代码的时候，并不想把我们生成的文件也签入到我们的Git代码库中，这时候我们可以手动删除生成的文件，但是有时候会忘记，也很麻烦，不小心还是会提交到Git中。要解决这个问题，我们可以使用<code>go clean</code>,它可以清理我们编译生成的文件，比如生成的可执行文件，生成obj对象等等。</p>

<pre><code class="language-bash">usage: go clean [-i] [-r] [-n] [-x] [build flags] [packages]
</code></pre>

<p>用法和<code>go build</code>基本一样，这样不再进行详细举例演示，可以参考<code>go build</code>的使用，更多关于<code>go clean</code>的使用，可以使用如下命令查看:</p>

<pre><code class="language-bash">go help clean
</code></pre>

<h2 id="go-run">go run</h2>

<p><code>go build</code>是先编译，然后我们在执行可以执行文件来运行我们的程序，需要两步。<code>go run</code>这个命令就是可以把这两步合成一步的命令，节省了我们录入的时间，通过<code>go run</code>命令，我们可以直接看到输出的结果。</p>

<pre><code class="language-bash">➜  ~ go help run
usage: go run [build flags] [-exec xprog] gofiles... [arguments...]

Run compiles and runs the main package comprising the named Go source files.
A Go source file is defined to be a file ending in a literal &quot;.go&quot; suffix.

By default, 'go run' runs the compiled binary directly: 'a.out arguments...'.
If the -exec flag is given, 'go run' invokes the binary using xprog:
	'xprog a.out arguments...'.
If the -exec flag is not given, GOOS or GOARCH is different from the system
default, and a program named go_$GOOS_$GOARCH_exec can be found
on the current search path, 'go run' invokes the binary using that program,
for example 'go_nacl_386_exec a.out arguments...'. This allows execution of
cross-compiled programs when a simulator or other execution method is
available.

For more about build flags, see 'go help build'.
</code></pre>

<p><code>go run</code>命令需要一个go文件作为参数，这个go文件必须包含main包和main函数，这样才可以运行，其他的参数和<code>go build</code>差不多。 在运行<code>go run</code>的时候，如果需要的话，我们可以给我们的程序传递参数，比如：</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;os&quot;
)


func main() {
	fmt.Println(&quot;输入的参数为：&quot;,os.Args[1])
}
</code></pre>

<p>打开终端，输入如下命令执行：</p>

<pre><code class="language-bash">go run main.go 12
</code></pre>

<p>这时候我们就可以看到输出：</p>

<pre><code class="language-bash">输入的参数为： 12
</code></pre>

<h2 id="go-env">go env</h2>

<p>在前面讲<code>go build</code>的时候，我们使用了<code>go env</code>命令查看了我们当前的go环境信息。</p>

<pre><code class="language-bash">➜  hello go help env
usage: go env [var ...]

Env prints Go environment information.

By default env prints information as a shell script
(on Windows, a batch file).  If one or more variable
names is given as arguments,  env prints the value of
each named variable on its own line.
</code></pre>

<p>使用<code>go env</code>查看我们的go环境信息，便于我们进行调试，排错等，因为有时候我们会遇到一些莫名其妙的问题，比如本来在MAC上开发，怎么编译出一个Linux的可执行文件等，遇到这类问题时，先查看我们的go环境信息，看看有没有哪里配置错了，一步步排错。</p>

<h2 id="go-install">go install</h2>

<p>从其名字上我们不难猜出这个命令是做什么的，它和<code>go build</code>类似，不过它可以在编译后，把生成的可执行文件或者库安装到对应的目录下，以供使用。</p>

<pre><code>➜  hello go help install
usage: go install [build flags] [packages]

Install compiles and installs the packages named by the import paths,
along with their dependencies.
</code></pre>

<p>它的用法和<code>go build</code>差不多，如果不指定一个包名，就使用当前目录。安装的目录都是约定好的，如果生成的是可执行文件，那么安装在<code>$GOPATH/bin</code>目录下；如果是可引用的库，那么安装在<code>$GOPATH/pkg</code>目录下。</p>

<h2 id="go-get">go get</h2>

<p><code>go get</code>命令，可以从网上下载更新指定的包以及依赖的包，并对它们进行编译和安装。</p>

<pre><code class="language-bash">go get github.com/spf13/cobra
</code></pre>

<p>以上示例，我们就可以从github上直接下载这个go库到我们<code>GOPATH</code>工作空间中，以供我们使用。下载的是整个源代码工程，并且会根据它们编译和安装，和执行<code>go install</code>类似。</p>

<p><code>go get</code>支持大多数版本控制系统(VCS)，比如我们常用的git，通过它和包依赖管理结合，我们可以在代码中直接导入网络上的包以供我们使用。</p>

<p>如果我们需要更新网络上的一个go工程，加<code>-u</code> 标记即可。</p>

<pre><code class="language-bash">go get -u github.com/spf13/cobra
</code></pre>

<p>类似的，启用<code>-v</code>标记，可以看到下载的进度以及更多的调试信息。关于<code>go get</code> 命令的更多用法，可以使用如下命令查看:</p>

<pre><code class="language-bash">go help get
</code></pre>

<h2 id="go-fmt">go fmt</h2>

<p>这是go提供的最帅的一个命令了，它可以格式化我们的源代码的布局和Go源代码一样的风格，也就是统一代码风格，这样我们再也不用为大括号要不要放到行尾还是另起一行，缩进是使用空格还是tab而争论不休了，都给我们统一了。</p>

<pre><code class="language-go">func main() { 
	fmt.Println(&quot;输入的参数为：&quot;, os.Args[1]) }
</code></pre>

<p>比如以上代码，我们执行<code>go fmt</code> 格式化后，会变成如下这样：</p>

<pre><code class="language-go">func main() {
	fmt.Println(&quot;输入的参数为：&quot;, os.Args[1])
}
</code></pre>

<p><code>go fmt</code>也是接受一个包名作为参数，如果不传递，则使用当前目录。<code>go fmt</code>会自动格式化代码文件并保存，它本质上其实是调用的<code>gofmt -l -w</code>这个命令，我们看下<code>gofmt</code>的使用帮助。</p>

<pre><code class="language-bash">➜  hello gofmt -h  
usage: gofmt [flags] [path ...]
  -cpuprofile string
    	write cpu profile to this file
  -d	display diffs instead of rewriting files
  -e	report all errors (not just the first 10 on different lines)
  -l	list files whose formatting differs from gofmt's
  -r string
    	rewrite rule (e.g., 'a[b:len(a)] -&gt; a[b:]')
  -s	simplify code
  -w	write result to (source) file instead of stdout
</code></pre>

<p><code>go fmt</code> 为我们统一了代码风格，这样我们在整个团队协作中发现，所有代码都是统一的，像一个人写的一样。所以我们的代码在提交到git库之前，一定要使用<code>go fmt</code>进行格式化，现在也有很多编辑器也可以在保存的时候，自动帮我们格式化代码。</p>

<h2 id="go-vet">go vet</h2>

<p>这个命令不会帮助开发人员写代码，但是它也很有用，因为它会帮助我们检查我们代码中常见的错误。</p>

<ol>
<li>Printf这类的函数调用时，类型匹配了错误的参数。</li>
<li>定义常用的方法时，方法签名错误。</li>
<li>错误的结构标签。</li>
<li>没有指定字段名的结构字面量。</li>
</ol>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
)

func main() {
	fmt.Printf(&quot; 哈哈&quot;,3.14)
}
</code></pre>

<p>这个例子是一个明显错误的例子，新手经常会犯，这里我们忘记输入了格式化的指令符，这种编辑器是检查不出来的，但是如果我们使用<code>go vet</code>就可以帮我们检查出这类常见的小错误。</p>

<pre><code class="language-bash">➜  hello go vet
main.go:8: no formatting directive in Printf call
</code></pre>

<p>看，提示多明显。其使用方式和<code>go fmt</code>一样，也是接受一个包名作为参数。</p>

<pre><code>usage: go vet [-n] [-x] [build flags] [packages]
</code></pre>

<p>养成在代码提交或者测试前，使用<code>go vet</code>检查代码的好习惯，可以避免一些常见问题。</p>

<h2 id="go-test">go test</h2>

<p>该命令用于Go的单元测试，它也是接受一个包名作为参数，如果没有指定，使用当前目录。 <code>go test</code>运行的单元测试必须符合go的测试要求。</p>

<ol>
<li>写有单元测试的文件名，必须以<code>_test.go</code>结尾。</li>
<li>测试文件要包含若干个测试函数。</li>
<li>这些测试函数要以Test为前缀，还要接收一个<code>*testing.T</code>类型的参数。</li>
</ol>

<pre><code class="language-go">package main

import &quot;testing&quot;

func TestAdd(t *testing.T) {
	if Add(1,2) == 3 {
		t.Log(&quot;1+2=3&quot;)
	}

	if Add(1,1) == 3 {
		t.Error(&quot;1+1=3&quot;)
	}
}
</code></pre>

<p>这是一个单元测试，保存在<code>main_test.go</code>文件中，对main包里的<code>Add(a,b int)</code>函数进行单元测试。 如果要运行这个单元测试，在该文件目录下，执行<code>go test</code> 即可。</p>

<pre><code class="language-bash">➜  hello go test
PASS
ok  	flysnow.org/hello	0.006s
</code></pre>

<p>以上是打印输出，测试通过。更多关于<code>go test</code>命令的使用，请通过如下命令查看。</p>

<pre><code class="language-bash">go help test
</code></pre>

<p>以上这些，主要时介绍的go这个开发工具常用的命令，熟悉了之后可以帮助我们更好的开发编码。《Go语言实战》中针对该部分做了一些介绍，但是比较少，只限于<code>go build</code>,<code>go clean</code>,<code>go fmt</code>,<code>go vet</code>这几个命令，这里进行了扩展，还加入了跨平台编译。</p>

<p>其他关于go工具提供的主题介绍，比如package是什么等等，可以直接使用<code>go help [topic]</code>命令查看。</p>

<pre><code class="language-bash">Additional help topics:

	c           calling between Go and C
	buildmode   description of build modes
	filetype    file types
	gopath      GOPATH environment variable
	environment environment variables
	importpath  import path syntax
	packages    description of package lists
	testflag    description of testing flags
	testfunc    description of testing functions

Use &quot;go help [topic]&quot; for more information about that topic.
</code></pre>

                        </div>

                        


                        


                        <div class="post-meta meta-tags">
                            
                            没有标签
                            
                        </div>
                    </article>
                    
    

    
    
                </div>
            </div>
            <div id="secondary">
    <section class="widget">
        <form id="search" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="http://gitzh2017.github.io/">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="http://gitzh2017.github.io/posts/01-golang/" title="【Golang系列】Go语言环境搭建">【Golang系列】Go语言环境搭建</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">分类</h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title">标签</h3>
<div class="tagcloud">
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="http://gitzh2017.github.io/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
        </div>
    </div>
</div>
<footer id="footer">
    <div class="container">
        &copy; 2019 <a href="http://gitzh2017.github.io/">凡夫俗子的博客 By 凡夫俗子</a>.
        Powered by <a rel="nofollow noreferer noopener" href="https://gohugo.io" target="_blank">Hugo</a>.
        <a href="https://www.flysnow.org/" target="_blank">Theme</a> based on <a href="https://github.com/rujews/maupassant-hugo" target="_blank">maupassant</a>.
        
    </div>
</footer>


    <script type="text/javascript">
    
    (function(){
        $("pre code").parent().addClass("line-numbers")
    }())

    window.MathJax = {
        tex2jax: {
            inlineMath: [ ['$','$'] ],
            processEscapes: true
        }
    };
    </script>
    <script type="text/javascript" src="/js/prism.js" async="true"></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src="/js/totop.js?v=0.0.0" async=""></script>






</body>
</html>
