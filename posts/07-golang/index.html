<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta name="generator" content="Hugo 0.55.6" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>[Golang系列]-Go基础语法之函数 | 凡夫俗子的博客</title>
    <meta property="og:title" content="[Golang系列]-Go基础语法之函数 - 凡夫俗子的博客">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content="2019-06-28T01:14:14&#43;08:00">
        
        
    <meta property="article:modified_time" content="2019-06-28T01:14:14&#43;08:00">
        
    <meta name="Keywords" content="golang,go语言,go语言笔记,kubernetes,项目管理,python">
    <meta name="description" content="[Golang系列]-Go基础语法之函数">
        
    <meta name="author" content="凡夫俗子">
    <meta property="og:url" content="http://gitzh2017.github.io/posts/07-golang/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href="/css/normalize.css">
    
        <link rel="stylesheet" href="/css/prism.css">
    
    <link rel="stylesheet" href="/css/style.css">
    <script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>

    


    
    
</head>

<body>
<header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="http://gitzh2017.github.io/">
                        凡夫俗子的博客
                    </a>
                
                <p class="description">专注于Kubernetes、Python、Go语言(golang)、Linux、项目管理、软件架构</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="http://gitzh2017.github.io/">首页</a>
                    
                    <a  href="http://gitzh2017.github.io/archives/" title="归档">归档</a>
                    
                    <a  href="http://gitzh2017.github.io/about/" title="关于">关于</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>


<div id="body">
    <div class="container">
        <div class="col-group">

            <div class="col-8" id="main">
                <div class="res-cons">
                    <article class="post">
                        <header>
                            <h1 class="post-title">[Golang系列]-Go基础语法之函数</h1>
                        </header>
                        <date class="post-meta meta-date">
                            2019年6月28日
                        </date>
                        
                        
                        
                        <div class="clear">
                            <div class="toc-article">
                                <div class="toc-title">文章目录</div>
                                <nav id="TableOfContents">
<ul>
<li><a href="#函数">函数</a>
<ul>
<li><a href="#函数定义">函数定义</a></li>
<li><a href="#函数的调用">函数的调用</a></li>
<li><a href="#参数">参数</a>
<ul>
<li><a href="#类型简写">类型简写</a></li>
<li><a href="#可变参数">可变参数</a></li>
</ul></li>
<li><a href="#返回值">返回值</a>
<ul>
<li><a href="#多返回值">多返回值</a></li>
<li><a href="#返回值命名">返回值命名</a></li>
</ul></li>
<li><a href="#defer语句">defer语句</a>
<ul>
<li><a href="#defer执行时机">defer执行时机</a></li>
<li><a href="#defer经典案例">defer经典案例</a></li>
<li><a href="#defer面试题">defer面试题</a></li>
</ul></li>
</ul></li>
<li><a href="#函数进阶">函数进阶</a>
<ul>
<li><a href="#变量作用域">变量作用域</a>
<ul>
<li><a href="#全局变量">全局变量</a></li>
<li><a href="#局部变量">局部变量</a></li>
</ul></li>
<li><a href="#函数类型与变量">函数类型与变量</a>
<ul>
<li><a href="#定义函数类型">定义函数类型</a></li>
<li><a href="#函数类型变量">函数类型变量</a></li>
</ul></li>
<li><a href="#高阶函数">高阶函数</a>
<ul>
<li><a href="#函数作为参数">函数作为参数</a></li>
<li><a href="#函数作为返回值">函数作为返回值</a></li>
</ul></li>
<li><a href="#匿名函数和闭包">匿名函数和闭包</a>
<ul>
<li><a href="#匿名函数">匿名函数</a></li>
<li><a href="#闭包">闭包</a></li>
</ul></li>
</ul></li>
<li><a href="#内置函数介绍">内置函数介绍</a>
<ul>
<li>
<ul>
<li><a href="#panic-recover">panic/recover</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
                            </div>
                        </div>
                        
                        <div class="post-content">
                            <p>函数是组织好的、可重复使用的、用于执行指定任务的代码块。本文介绍了Go语言中函数的相关内容。</p>

<h1 id="函数">函数</h1>

<p>Go语言中支持函数、匿名函数和闭包，并且函数在Go语言中属于“一等公民”。</p>

<h2 id="函数定义">函数定义</h2>

<p>Go语言中定义函数使用<code>func</code>关键字，具体格式如下：</p>

<pre><code class="language-go">func 函数名(参数)(返回值){
    函数体
}
</code></pre>

<p><strong>其中：</strong>
- <code>函数名</code>：由字母、数字、下划线组成。但函数名的第一个字母不能是数字。在同一个包内，函数名也称不能重名。
- <code>参数</code>：参数由参数变量和参数变量的类型组成，多个参数之间使用,分隔。
- <code>返回值</code>：返回值由返回值变量和其变量类型组成，也可以只写返回值的类型，多个返回值必须用()包裹，并用,分隔。
- <code>函数体</code>：实现指定功能的代码块。</p>

<p>我们先来定义一个求两个数之和的函数：</p>

<pre><code class="language-go">func intSum(x int, y int) int {
	return x + y
}
</code></pre>

<p>函数的参数和返回值都是可选的，例如我们可以实现一个既不需要参数也没有返回值的函数：</p>

<pre><code class="language-go">func sayHello() {
	fmt.Println(&quot;Hello 沙河&quot;)
}
</code></pre>

<h2 id="函数的调用">函数的调用</h2>

<p>定义了函数之后，我们可以通过<code>函数名()</code>的方式调用函数。 例如我们调用上面定义的两个函数，代码如下：</p>

<pre><code class="language-go">func main() {
	sayHello()
	ret := intSum(10, 20)
	fmt.Println(ret)
}
</code></pre>

<p>注意，调用有返回值的函数时，可以不接收其返回值。</p>

<h2 id="参数">参数</h2>

<h3 id="类型简写">类型简写</h3>

<p>函数的参数中如果相邻变量的类型相同，则可以省略类型，例如：</p>

<pre><code class="language-go">func intSum(x, y int) int {
	return x + y
}
</code></pre>

<p>上面的代码中，intSum函数有两个参数，这两个参数的类型均为int，因此可以省略x的类型，因为y后面有类型说明，x参数也是该类型。</p>

<h3 id="可变参数">可变参数</h3>

<p>可变参数是指函数的参数数量不固定。Go语言中的可变参数通过在参数名后加&hellip;来标识。</p>

<p>注意：可变参数通常要作为函数的最后一个参数。</p>

<p>举个例子：</p>

<pre><code class="language-go">func intSum2(x ...int) int {
	fmt.Println(x) //x是一个切片
	sum := 0
	for _, v := range x {
		sum = sum + v
	}
	return sum
}
</code></pre>

<p>调用上面的函数：</p>

<pre><code class="language-go">ret1 := intSum2()
ret2 := intSum2(10)
ret3 := intSum2(10, 20)
ret4 := intSum2(10, 20, 30)
fmt.Println(ret1, ret2, ret3, ret4) //0 10 30 60
</code></pre>

<p>固定参数搭配可变参数使用时，可变参数要放在固定参数的后面，示例代码如下：</p>

<pre><code class="language-go">func intSum3(x int, y ...int) int {
	fmt.Println(x, y)
	sum := x
	for _, v := range y {
		sum = sum + v
	}
	return sum
}
</code></pre>

<p>调用上述函数：</p>

<pre><code class="language-go">ret5 := intSum3(100)
ret6 := intSum3(100, 10)
ret7 := intSum3(100, 10, 20)
ret8 := intSum3(100, 10, 20, 30)
fmt.Println(ret5, ret6, ret7, ret8) //100 110 130 160
</code></pre>

<p>本质上，函数的可变参数是通过切片来实现的。</p>

<h2 id="返回值">返回值</h2>

<p>Go语言中通过<code>return</code>关键字向外输出返回值。</p>

<h3 id="多返回值">多返回值</h3>

<p>Go语言中函数支持多返回值，函数如果有多个返回值时必须用<code>()</code>将所有返回值包裹起来。</p>

<p>举个例子：</p>

<pre><code class="language-go">func calc(x, y int) (int, int) {
	sum := x + y
	sub := x - y
	return sum, sub
}
</code></pre>

<h3 id="返回值命名">返回值命名</h3>

<p>函数定义时可以给返回值命名，并在函数体中直接使用这些变量，最后通过<code>return</code>关键字返回。</p>

<p>例如：</p>

<pre><code class="language-go">func calc(x, y int) (sum, sub int) {
	sum = x + y
	sub = x - y
	return
}
</code></pre>

<h2 id="defer语句">defer语句</h2>

<p>Go语言中的<code>defer</code>语句会将其后面跟随的语句进行延迟处理。在<code>defer</code>归属的函数即将返回时，将延迟处理的语句按<code>defer</code>定义的逆序进行执行，也就是说，先被<code>defer</code>的语句最后被执行，最后被<code>defer</code>的语句，最先被执行。</p>

<p>举个例子：</p>

<pre><code class="language-go">func main() {
	fmt.Println(&quot;start&quot;)
	defer fmt.Println(1)
	defer fmt.Println(2)
	defer fmt.Println(3)
	fmt.Println(&quot;end&quot;)
}
</code></pre>

<p>输出结果：</p>

<pre><code class="language-go">start
end
3
2
1
</code></pre>

<p>由于<code>defer</code>语句延迟调用的特性，所以<code>defer</code>语句能非常方便的处理资源释放问题。比如：资源清理、文件关闭、解锁及记录时间等。</p>

<h3 id="defer执行时机">defer执行时机</h3>

<p>在Go语言的函数中<code>return</code>语句在底层并不是原子操作，它分为给返回值赋值和RET指令两步。而<code>defer</code>语句执行的时机就在返回值赋值操作后，RET指令执行前。具体如下图所示：</p>

<p><img src="/images/07Golang/07golang.png" alt="install_go" /></p>

<h3 id="defer经典案例">defer经典案例</h3>

<p>阅读下面的代码，写出最后的打印结果。</p>

<pre><code class="language-go">func f1() int {
	x := 5
	defer func() {
		x++
	}()
	return x
}

func f2() (x int) {
	defer func() {
		x++
	}()
	return 5
}

func f3() (y int) {
	x := 5
	defer func() {
		x++
	}()
	return x
}
func f4() (x int) {
	defer func(x int) {
		x++
	}(x)
	return 5
}
func main() {
	fmt.Println(f1())
	fmt.Println(f2())
	fmt.Println(f3())
	fmt.Println(f4())
}
</code></pre>

<h3 id="defer面试题">defer面试题</h3>

<pre><code class="language-go">func calc(index string, a, b int) int {
	ret := a + b
	fmt.Println(index, a, b, ret)
	return ret
}

func main() {
	a := 1
	b := 2
	defer calc(&quot;1&quot;, a, calc(&quot;10&quot;, a, b))
	a = 0
	defer calc(&quot;2&quot;, a, calc(&quot;20&quot;, a, b))
	b = 1
}
</code></pre>

<p>问，上面代码的输出结果是？</p>

<h1 id="函数进阶">函数进阶</h1>

<h2 id="变量作用域">变量作用域</h2>

<h3 id="全局变量">全局变量</h3>

<p>全局变量是定义在函数外部的变量，它在程序整个运行周期内都有效。 在函数中可以访问到全局变量。</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

//定义全局变量num
var num int64 = 10

func testGlobalVar() {
	fmt.Printf(&quot;num=%d\n&quot;, num) //函数中可以访问全局变量num
}
func main() {
	testGlobalVar() //num=10
}
</code></pre>

<h3 id="局部变量">局部变量</h3>

<p>局部变量又分为两种： 函数内定义的变量无法在该函数外使用，例如下面的示例代码main函数中无法使用testLocalVar函数中定义的变量x：</p>

<pre><code class="language-go">func testLocalVar() {
	//定义一个函数局部变量x,仅在该函数内生效
	var x int64 = 100
	fmt.Printf(&quot;x=%d\n&quot;, x)
}

func main() {
	testLocalVar()
	fmt.Println(x) // 此时无法使用变量x
}
</code></pre>

<p>如果局部变量和全局变量重名，优先访问局部变量。</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

//定义全局变量num
var num int64 = 10

func testNum() {
	num := 100
	fmt.Printf(&quot;num=%d\n&quot;, num) //函数中优先使用局部变量
}
func main() {
	testNum() //num=10
}
</code></pre>

<p>接下来我们来看一下语句块定义的变量，通常我们会在if条件判断、for循环、switch语句上使用这种定义变量的方式。</p>

<pre><code class="language-go">func testLocalVar2(x, y int) {
	fmt.Println(x, y) //函数的参数也是只在本函数中生效
	if x &gt; 0 {
		z := 100 //变量z只在if语句块生效
		fmt.Println(z)
	}
	//fmt.Println(z)//此处无法使用变量z
}
</code></pre>

<p>还有我们之前讲过的for循环语句中定义的变量，也是只在for语句块中生效：</p>

<pre><code class="language-go">func testLocalVar3() {
	for i := 0; i &lt; 10; i++ {
		fmt.Println(i) //变量i只在当前for语句块中生效
	}
	//fmt.Println(i) //此处无法使用变量i
}
</code></pre>

<h2 id="函数类型与变量">函数类型与变量</h2>

<h3 id="定义函数类型">定义函数类型</h3>

<p>我们可以使用<code>type</code>关键字来定义一个函数类型，具体格式如下：</p>

<pre><code class="language-go">type calculation func(int, int) int
</code></pre>

<p>上面语句定义了一个<code>calculation</code>类型，它是一种函数类型，这种函数接收两个int类型的参数并且返回一个int类型的返回值。</p>

<p>简单来说，凡是满足这个条件的函数都是calculation类型的函数，例如下面的add和sub是calculation类型。</p>

<pre><code class="language-go">func add(x, y int) int {
	return x + y
}

func sub(x, y int) int {
	return x - y
}
</code></pre>

<p>add和sub都能赋值给calculation类型的变量。</p>

<pre><code class="language-go">var c calculation
c = add
</code></pre>

<h3 id="函数类型变量">函数类型变量</h3>

<p>我们可以声明函数类型的变量并且为该变量赋值：</p>

<pre><code class="language-go">func main() {
	var c calculation               // 声明一个calculation类型的变量c
	c = add                         // 把add赋值给c
	fmt.Printf(&quot;type of c:%T\n&quot;, c) // type of c:main.calculation
	fmt.Println(c(1, 2))            // 像调用add一样调用c

	f := add                        // 将函数add赋值给变量f1
	fmt.Printf(&quot;type of f:%T\n&quot;, f) // type of f:func(int, int) int
	fmt.Println(f(10, 20))          // 像调用add一样调用f
}
</code></pre>

<h2 id="高阶函数">高阶函数</h2>

<p>高阶函数分为函数作为参数和函数作为返回值两部分。</p>

<h3 id="函数作为参数">函数作为参数</h3>

<p>函数可以作为参数：</p>

<pre><code class="language-go">func add(x, y int) int {
	return x + y
}
func calc(x, y int, op func(int, int) int) int {
	return op(x, y)
}
func main() {
	ret2 := calc(10, 20, add)
	fmt.Println(ret2) //30
}
</code></pre>

<h3 id="函数作为返回值">函数作为返回值</h3>

<p>函数也可以作为返回值：</p>

<pre><code class="language-go">func do(s string) (func(int, int) int, error) {
	switch s {
	case &quot;+&quot;:
		return add, nil
	case &quot;-&quot;:
		return sub, nil
	default:
		err := errors.New(&quot;无法识别的操作符&quot;)
		return nil, err
	}
}
</code></pre>

<h2 id="匿名函数和闭包">匿名函数和闭包</h2>

<h3 id="匿名函数">匿名函数</h3>

<p>函数当然还可以作为返回值，但是在Go语言中函数内部不能再像之前那样定义函数了，只能定义匿名函数。匿名函数就是没有函数名的函数，匿名函数的定义格式如下：</p>

<pre><code class="language-go">func(参数)(返回值){
    函数体
}
</code></pre>

<p>匿名函数因为没有函数名，所以没办法像普通函数那样调用，所以匿名函数需要保存到某个变量或者作为立即执行函数:</p>

<pre><code class="language-go">func main() {
	// 将匿名函数保存到变量
	add := func(x, y int) {
		fmt.Println(x + y)
	}
	add(10, 20) // 通过变量调用匿名函数

	//自执行函数：匿名函数定义完加()直接执行
	func(x, y int) {
		fmt.Println(x + y)
	}(10, 20)
}
</code></pre>

<p>匿名函数多用于实现回调函数和闭包。</p>

<h3 id="闭包">闭包</h3>

<p>闭包指的是一个函数和与其相关的引用环境组合而成的实体。简单来说，<code>闭包=函数+引用环境</code>。 首先我们来看一个例子：</p>

<pre><code class="language-go">func adder() func(int) int {
	var x int
	return func(y int) int {
		x += y
		return x
	}
}
func main() {
	var f = adder()
	fmt.Println(f(10)) //10
	fmt.Println(f(20)) //30
	fmt.Println(f(30)) //60

	f1 := adder()
	fmt.Println(f1(40)) //40
	fmt.Println(f1(50)) //90
}
</code></pre>

<p>变量<code>f</code>是一个函数并且它引用了其外部作用域中的<code>x</code>变量，此时<code>f</code>就是一个闭包。 在<code>f</code>的生命周期内，变量<code>x</code>也一直有效。 闭包进阶示例1：</p>

<pre><code class="language-go">func adder2(x int) func(int) int {
	return func(y int) int {
		x += y
		return x
	}
}
func main() {
	var f = adder2(10)
	fmt.Println(f(10)) //20
	fmt.Println(f(20)) //40
	fmt.Println(f(30)) //70

	f1 := adder2(20)
	fmt.Println(f1(40)) //60
	fmt.Println(f1(50)) //110
}
</code></pre>

<p>闭包进阶示例2：</p>

<pre><code class="language-go">func makeSuffixFunc(suffix string) func(string) string {
	return func(name string) string {
		if !strings.HasSuffix(name, suffix) {
			return name + suffix
		}
		return name
	}
}

func main() {
	jpgFunc := makeSuffixFunc(&quot;.jpg&quot;)
	txtFunc := makeSuffixFunc(&quot;.txt&quot;)
	fmt.Println(jpgFunc(&quot;test&quot;)) //test.jpg
	fmt.Println(txtFunc(&quot;test&quot;)) //test.txt
}
</code></pre>

<p>闭包进阶示例3：</p>

<pre><code class="language-go">func calc(base int) (func(int) int, func(int) int) {
	add := func(i int) int {
		base += i
		return base
	}

	sub := func(i int) int {
		base -= i
		return base
	}
	return add, sub
}

func main() {
	f1, f2 := calc(10)
	fmt.Println(f1(1), f2(2)) //11 9
	fmt.Println(f1(3), f2(4)) //12 8
	fmt.Println(f1(5), f2(6)) //13 7
}
</code></pre>

<p>闭包其实并不复杂，只要牢记<code>闭包=函数+引用环境</code>。</p>

<h1 id="内置函数介绍">内置函数介绍</h1>

<table>
<thead>
<tr>
<th>内置函数</th>
<th>介绍</th>
</tr>
</thead>

<tbody>
<tr>
<td>close</td>
<td>主要用来关闭channel</td>
</tr>

<tr>
<td>len</td>
<td>用来求长度，比如string、array、slice、map、channel</td>
</tr>

<tr>
<td>new</td>
<td>用来分配内存，主要用来分配值类型，比如int、struct。返回的是指针</td>
</tr>

<tr>
<td>make</td>
<td>用来分配内存，主要用来分配引用类型，比如chan、map、slice</td>
</tr>

<tr>
<td>append</td>
<td>用来追加元素到数组、slice中</td>
</tr>

<tr>
<td>panic和recover</td>
<td>用来做错误处理</td>
</tr>
</tbody>
</table>

<h3 id="panic-recover">panic/recover</h3>

<p>Go语言中目前（Go1.12）是没有异常机制，但是使用<code>panic/recover</code>模式来处理错误。 <code>panic</code>可以在任何地方引发，但<code>recover</code>只有在<code>defer</code>调用的函数中有效。 首先来看一个例子：</p>

<pre><code class="language-go">func funcA() {
	fmt.Println(&quot;func A&quot;)
}

func funcB() {
	panic(&quot;panic in B&quot;)
}

func funcC() {
	fmt.Println(&quot;func C&quot;)
}
func main() {
	funcA()
	funcB()
	funcC()
}
</code></pre>

<p>输出：</p>

<pre><code class="language-bash">func A
panic: panic in B

goroutine 1 [running]:
main.funcB(...)
        .../code/func/main.go:12
main.main()
        .../code/func/main.go:20 +0x98
</code></pre>

<p>程序运行期间<code>funcB</code>中引发了<code>panic</code>导致程序崩溃，异常退出了。这个时候我们就可以通过<code>recover</code>将程序恢复回来，继续往后执行。</p>

<pre><code class="language-go">func funcA() {
	fmt.Println(&quot;func A&quot;)
}

func funcB() {
	defer func() {
		err := recover()
		//如果程序出出现了panic错误,可以通过recover恢复过来
		if err != nil {
			fmt.Println(&quot;recover in B&quot;)
		}
	}()
	panic(&quot;panic in B&quot;)
}

func funcC() {
	fmt.Println(&quot;func C&quot;)
}
func main() {
	funcA()
	funcB()
	funcC()
}
</code></pre>

<p><strong>注意：</strong>
- <code>recover()</code>必须搭配<code>defer</code>使用。
- defer一定要在可能引发panic的语句之前定义。</p>
                        </div>

                        


                        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/06-golang/">[Golang系列]-Go基础语法之流程控制</a></li>
        
        <li><a href="/posts/05-golang/">[Golang系列]-Go基础语法之运算符</a></li>
        
        <li><a href="/posts/04-golang/">[Golang系列]-Go基础语法之基础数据类型</a></li>
        
        <li><a href="/posts/03-golang/">[Golang系列]-Go基础语法之变量与常量</a></li>
        
        <li><a href="/posts/02-golang/">[Golang系列]-Go开发环境 VS Code</a></li>
        
    </ul>
</div>


                        <div class="post-meta meta-tags">
                            
                            没有标签
                            
                        </div>
                    </article>
                    
    

    
    
                </div>
            </div>
            <div id="secondary">
    <section class="widget">
        <form id="search" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="http://gitzh2017.github.io/">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="http://gitzh2017.github.io/posts/11-golang/" title="[Golang系列]-Go基础语法之指针">[Golang系列]-Go基础语法之指针</a>
    </li>
    
    <li>
        <a href="http://gitzh2017.github.io/posts/10-golang/" title="[Golang系列]-Go基础语法之map">[Golang系列]-Go基础语法之map</a>
    </li>
    
    <li>
        <a href="http://gitzh2017.github.io/posts/09-golang/" title="[Golang系列]-Go基础语法之切片">[Golang系列]-Go基础语法之切片</a>
    </li>
    
    <li>
        <a href="http://gitzh2017.github.io/posts/08-golang/" title="[Golang系列]-Go基础语法之数组">[Golang系列]-Go基础语法之数组</a>
    </li>
    
    <li>
        <a href="http://gitzh2017.github.io/posts/07-golang/" title="[Golang系列]-Go基础语法之函数">[Golang系列]-Go基础语法之函数</a>
    </li>
    
    <li>
        <a href="http://gitzh2017.github.io/posts/06-golang/" title="[Golang系列]-Go基础语法之流程控制">[Golang系列]-Go基础语法之流程控制</a>
    </li>
    
    <li>
        <a href="http://gitzh2017.github.io/posts/05-golang/" title="[Golang系列]-Go基础语法之运算符">[Golang系列]-Go基础语法之运算符</a>
    </li>
    
    <li>
        <a href="http://gitzh2017.github.io/posts/04-golang/" title="[Golang系列]-Go基础语法之基础数据类型">[Golang系列]-Go基础语法之基础数据类型</a>
    </li>
    
    <li>
        <a href="http://gitzh2017.github.io/posts/03-golang/" title="[Golang系列]-Go基础语法之变量与常量">[Golang系列]-Go基础语法之变量与常量</a>
    </li>
    
    <li>
        <a href="http://gitzh2017.github.io/posts/02-golang/" title="[Golang系列]-Go开发环境 VS Code">[Golang系列]-Go开发环境 VS Code</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">分类</h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title">标签</h3>
<div class="tagcloud">
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="http://gitzh2017.github.io/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
        </div>
    </div>
</div>
<footer id="footer">
    <div class="container">
        &copy; 2019 <a href="http://gitzh2017.github.io/">凡夫俗子的博客 By 凡夫俗子</a>.
        Powered by <a rel="nofollow noreferer noopener" href="https://gohugo.io" target="_blank">Hugo</a>.
        <a href="https://www.flysnow.org/" target="_blank">Theme</a> based on <a href="https://github.com/rujews/maupassant-hugo" target="_blank">maupassant</a>.
        
    </div>
</footer>


    <script type="text/javascript">
    
    (function(){
        $("pre code").parent().addClass("line-numbers")
    }())

    window.MathJax = {
        tex2jax: {
            inlineMath: [ ['$','$'] ],
            processEscapes: true
        }
    };
    </script>
    <script type="text/javascript" src="/js/prism.js" async="true"></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src="/js/totop.js?v=0.0.0" async=""></script>






</body>
</html>
