<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta name="generator" content="Hugo 0.55.6" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>[Golang系列]-Go基础语法之切片 | 凡夫俗子的博客</title>
    <meta property="og:title" content="[Golang系列]-Go基础语法之切片 - 凡夫俗子的博客">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content="2019-06-28T01:14:21&#43;08:00">
        
        
    <meta property="article:modified_time" content="2019-06-28T01:14:21&#43;08:00">
        
    <meta name="Keywords" content="golang,go语言,go语言笔记,kubernetes,项目管理,python">
    <meta name="description" content="[Golang系列]-Go基础语法之切片">
        
    <meta name="author" content="凡夫俗子">
    <meta property="og:url" content="http://gitzh2017.github.io/posts/09-golang/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href="/css/normalize.css">
    
        <link rel="stylesheet" href="/css/prism.css">
    
    <link rel="stylesheet" href="/css/style.css">
    <script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>

    


    
    
</head>

<body>
<header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="http://gitzh2017.github.io/">
                        凡夫俗子的博客
                    </a>
                
                <p class="description">专注于Kubernetes、Python、Go语言(golang)、Linux、项目管理、软件架构</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="http://gitzh2017.github.io/">首页</a>
                    
                    <a  href="http://gitzh2017.github.io/archives/" title="归档">归档</a>
                    
                    <a  href="http://gitzh2017.github.io/about/" title="关于">关于</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>


<div id="body">
    <div class="container">
        <div class="col-group">

            <div class="col-8" id="main">
                <div class="res-cons">
                    <article class="post">
                        <header>
                            <h1 class="post-title">[Golang系列]-Go基础语法之切片</h1>
                        </header>
                        <date class="post-meta meta-date">
                            2019年6月28日
                        </date>
                        
                        
                        
                        <div class="clear">
                            <div class="toc-article">
                                <div class="toc-title">文章目录</div>
                                <nav id="TableOfContents">
<ul>
<li><a href="#切片">切片</a>
<ul>
<li><a href="#切片的定义">切片的定义</a>
<ul>
<li><a href="#切片的长度和容量">切片的长度和容量</a></li>
<li><a href="#基于数组定义切片">基于数组定义切片</a></li>
<li><a href="#切片再切片">切片再切片</a></li>
<li><a href="#使用make-函数构造切片">使用make()函数构造切片</a></li>
<li><a href="#切片的本质">切片的本质</a></li>
</ul></li>
<li><a href="#切片不能直接比较">切片不能直接比较</a></li>
<li><a href="#切片的赋值拷贝">切片的赋值拷贝</a></li>
<li><a href="#切片遍历">切片遍历</a></li>
<li><a href="#append-方法为切片添加元素">append()方法为切片添加元素</a></li>
<li><a href="#切片的扩容策略">切片的扩容策略</a></li>
<li><a href="#使用copy-函数复制切片">使用copy()函数复制切片</a></li>
<li><a href="#从切片中删除元素">从切片中删除元素</a></li>
</ul></li>
</ul>
</nav>
                            </div>
                        </div>
                        
                        <div class="post-content">
                            <p>本文主要介绍Go语言中切片（slice）及它的基本使用。</p>

<p>因为数组的长度是固定的并且数组长度属于类型的一部分，所以数组有很多的局限性。 例如：</p>

<pre><code class="language-go">func arraySum(x [3]int) int{
    sum := 0
    for _, v := range x{
        sum = sum + v
    }
    return sum
}
</code></pre>

<p>这个求和函数只能接受[3]int类型，其他的都不支持。 再比如，</p>

<pre><code class="language-go">a := [3]int{1, 2, 3}
</code></pre>

<p>数组a中已经有三个元素了，我们不能再继续往数组a中添加新元素了。</p>

<h1 id="切片">切片</h1>

<p>切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。</p>

<p>切片是一个引用类型，它的内部结构包含地址、长度和容量。切片一般用于快速地操作一块数据集合。</p>

<h2 id="切片的定义">切片的定义</h2>

<p>声明切片类型的基本语法如下：</p>

<pre><code class="language-go">var name []T
</code></pre>

<p>其中，
- name:表示变量名
- T:表示切片中的元素类型</p>

<p>举个例子：</p>

<pre><code class="language-go">func main() {
	// 声明切片类型
	var a []string              //声明一个字符串切片
	var b = []int{}             //声明一个整型切片并初始化
	var c = []bool{false, true} //声明一个布尔切片并初始化
	var d = []bool{false, true} //声明一个布尔切片并初始化
	fmt.Println(a)              //[]
	fmt.Println(b)              //[]
	fmt.Println(c)              //[false true]
	fmt.Println(a == nil)       //true
	fmt.Println(b == nil)       //false
	fmt.Println(c == nil)       //false
	// fmt.Println(c == d)   //切片是引用类型，不支持直接比较，只能和nil比较
}
</code></pre>

<h3 id="切片的长度和容量">切片的长度和容量</h3>

<p>切片拥有自己的长度和容量，我们可以通过使用内置的len()函数求长度，使用内置的cap()函数求切片的容量。</p>

<h3 id="基于数组定义切片">基于数组定义切片</h3>

<p>由于切片的底层就是一个数组，所以我们可以基于数组定义切片。</p>

<pre><code class="language-go">func main() {
	// 基于数组定义切片
	a := [5]int{55, 56, 57, 58, 59}
	b := a[1:4]                     //基于数组a创建切片，包括元素a[1],a[2],a[3]
	fmt.Println(b)                  //[56 57 58]
	fmt.Printf(&quot;type of b:%T\n&quot;, b) //type of b:[]int
}
</code></pre>

<p>还支持如下方式：</p>

<pre><code class="language-go">c := a[1:] //[56 57 58 59]
d := a[:4] //[55 56 57]
e := a[:]  //[55 56 57 58 59]
</code></pre>

<h3 id="切片再切片">切片再切片</h3>

<p>除了基于数组得到切片，我们还可以通过切片来得到切片。</p>

<pre><code class="language-go">func main() {
	//切片再切片
	a := [...]string{&quot;北京&quot;, &quot;上海&quot;, &quot;广州&quot;, &quot;深圳&quot;, &quot;成都&quot;, &quot;重庆&quot;}
	fmt.Printf(&quot;a:%v type:%T len:%d  cap:%d\n&quot;, a, a, len(a), cap(a))
	b := a[1:3]
	fmt.Printf(&quot;b:%v type:%T len:%d  cap:%d\n&quot;, b, b, len(b), cap(b))
	c := b[1:5]
	fmt.Printf(&quot;c:%v type:%T len:%d  cap:%d\n&quot;, c, c, len(c), cap(c))
}
</code></pre>

<p>输出：</p>

<pre><code class="language-bash">a:[北京 上海 广州 深圳 成都 重庆] type:[6]string len:6  cap:6
b:[上海 广州] type:[]string len:2  cap:5
c:[广州 深圳 成都 重庆] type:[]string len:4  cap:4
</code></pre>

<p><strong>注意：</strong> 对切片进行再切片时，索引不能超过原数组的长度，否则会出现索引越界的错误。</p>

<h3 id="使用make-函数构造切片">使用make()函数构造切片</h3>

<p>我们上面都是基于数组来创建的切片，如果需要动态的创建一个切片，我们就需要使用内置的<code>make()</code>函数，格式如下：</p>

<pre><code class="language-bash">make([]T, size, cap)
</code></pre>

<p>其中：</p>

<ul>
<li>T:切片的元素类型</li>
<li>size:切片中元素的数量</li>
<li>cap:切片的容量</li>
</ul>

<p>举个例子：</p>

<pre><code class="language-go">func main() {
	a := make([]int, 2, 10)
	fmt.Println(a)      //[0 0]
	fmt.Println(len(a)) //2
	fmt.Println(cap(a)) //10
}
</code></pre>

<p>上面代码中<code>a</code>的内部存储空间已经分配了10个，但实际上只用了2个。 容量并不会影响当前元素的个数，所以<code>len(a)</code>返回2，<code>cap(a)</code>则返回该切片的容量。</p>

<h3 id="切片的本质">切片的本质</h3>

<p>切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。</p>

<p>举个例子，现在有一个数组<code>a := [8]int{0, 1, 2, 3, 4, 5, 6, 7}</code>，切片<code>s1 := a[:5]</code>，相应示意图如下。
<img src="/images/09Golang/slice_01.png" alt="install_go" />
切片<code>s2 := a[3:6]</code>，相应示意图如下：
<img src="/images/09Golang/slice_02.png" alt="install_go" />)</p>

<h2 id="切片不能直接比较">切片不能直接比较</h2>

<p>切片之间是不能比较的，我们不能使用<code>==</code>操作符来判断两个切片是否含有全部相等元素。 切片唯一合法的比较操作是和<code>nil</code>比较。 一个<code>nil</code>值的切片并没有底层数组，一个<code>nil</code>值的切片的长度和容量都是0。但是我们不能说一个长度和容量都是0的切片一定是<code>nil</code>，例如下面的示例：</p>

<pre><code class="language-go">var s1 []int         //len(s1)=0;cap(s1)=0;s1==nil
s2 := []int{}        //len(s2)=0;cap(s2)=0;s2!=nil
s3 := make([]int, 0) //len(s3)=0;cap(s3)=0;s3!=nil
</code></pre>

<p>所以要判断一个切片是否是空的，要是用<code>len(s) == 0</code>来判断，不应该使用<code>s == nil</code>来判断。</p>

<h2 id="切片的赋值拷贝">切片的赋值拷贝</h2>

<p>下面的代码中演示了拷贝前后两个变量共享底层数组，对一个切片的修改会影响另一个切片的内容，这点需要特别注意。</p>

<pre><code class="language-go">func main() {
	s1 := make([]int, 3) //[0 0 0]
	s2 := s1             //将s1直接赋值给s2，s1和s2共用一个底层数组
	s2[0] = 100
	fmt.Println(s1) //[100 0 0]
	fmt.Println(s2) //[100 0 0]
}
</code></pre>

<h2 id="切片遍历">切片遍历</h2>

<p>切片的遍历方式和数组是一致的，支持索引遍历和<code>for range</code>遍历。</p>

<pre><code class="language-go">func main() {
	s := []int{1, 3, 5}

	for i := 0; i &lt; len(s); i++ {
		fmt.Println(i, s[i])
	}

	for index, value := range s {
		fmt.Println(index, value)
	}
}
</code></pre>

<h2 id="append-方法为切片添加元素">append()方法为切片添加元素</h2>

<p>Go语言的内建函数<code>append()</code>可以为切片动态添加元素。 每个切片会指向一个底层数组，这个数组能容纳一定数量的元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。“扩容”操作往往发生在<code>append()</code>函数调用时。 举个例子：</p>

<pre><code class="language-go">func main() {
	//append()添加元素和切片扩容
	var numSlice []int
	for i := 0; i &lt; 10; i++ {
		numSlice = append(numSlice, i)
		fmt.Printf(&quot;%v  len:%d  cap:%d  ptr:%p\n&quot;, numSlice, len(numSlice), cap(numSlice), numSlice)
	}
}
</code></pre>

<p>输出：</p>

<pre><code class="language-bash">[0]  len:1  cap:1  ptr:0xc0000a8000
[0 1]  len:2  cap:2  ptr:0xc0000a8040
[0 1 2]  len:3  cap:4  ptr:0xc0000b2020
[0 1 2 3]  len:4  cap:4  ptr:0xc0000b2020
[0 1 2 3 4]  len:5  cap:8  ptr:0xc0000b6000
[0 1 2 3 4 5]  len:6  cap:8  ptr:0xc0000b6000
[0 1 2 3 4 5 6]  len:7  cap:8  ptr:0xc0000b6000
[0 1 2 3 4 5 6 7]  len:8  cap:8  ptr:0xc0000b6000
[0 1 2 3 4 5 6 7 8]  len:9  cap:16  ptr:0xc0000b8000
[0 1 2 3 4 5 6 7 8 9]  len:10  cap:16  ptr:0xc0000b8000
</code></pre>

<p>从上面的结果可以看出：</p>

<ol>
<li><code>append()</code>函数将元素追加到切片的最后并返回该切片。</li>
<li>切片numSlice的容量按照1，2，4，8，16这样的规则自动进行扩容，每次扩容后都是扩容前的2倍。</li>
</ol>

<p>append()函数还支持一次性追加多个元素。 例如：</p>

<pre><code class="language-go">var citySlice []string
// 追加一个元素
citySlice = append(citySlice, &quot;北京&quot;)
// 追加多个元素
citySlice = append(citySlice, &quot;上海&quot;, &quot;广州&quot;, &quot;深圳&quot;)
// 追加切片
a := []string{&quot;成都&quot;, &quot;重庆&quot;}
citySlice = append(citySlice, a...)
fmt.Println(citySlice) //[北京 上海 广州 深圳 成都 重庆]
</code></pre>

<h2 id="切片的扩容策略">切片的扩容策略</h2>

<p>可以通过查看<code>$GOROOT/src/runtime/slice.go</code>源码，其中扩容相关代码如下：</p>

<pre><code class="language-go">newcap := old.cap
doublecap := newcap + newcap
if cap &gt; doublecap {
	newcap = cap
} else {
	if old.len &lt; 1024 {
		newcap = doublecap
	} else {
		// Check 0 &lt; newcap to detect overflow
		// and prevent an infinite loop.
		for 0 &lt; newcap &amp;&amp; newcap &lt; cap {
			newcap += newcap / 4
		}
		// Set newcap to the requested cap when
		// the newcap calculation overflowed.
		if newcap &lt;= 0 {
			newcap = cap
		}
	}
}
</code></pre>

<p>从上面的代码可以看出以下内容：</p>

<ul>
<li>首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）。</li>
<li>否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap），</li>
<li>否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;= cap）</li>
<li>如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）。</li>
</ul>

<p>需要注意的是，切片扩容还会根据切片中元素的类型不同而做不同的处理，比如<code>int</code>和<code>string</code>类型的处理方式就不一样。</p>

<h2 id="使用copy-函数复制切片">使用copy()函数复制切片</h2>

<p>首先我们来看一个问题：</p>

<pre><code class="language-go">func main() {
	a := []int{1, 2, 3, 4, 5}
	b := a
	fmt.Println(a) //[1 2 3 4 5]
	fmt.Println(b) //[1 2 3 4 5]
	b[0] = 1000
	fmt.Println(a) //[1000 2 3 4 5]
	fmt.Println(b) //[1000 2 3 4 5]
}
</code></pre>

<p>由于切片是引用类型，所以a和b其实都指向了同一块内存地址。修改b的同时a的值也会发生变化。</p>

<p>Go语言内建的<code>copy()</code>函数可以迅速地将一个切片的数据复制到另外一个切片空间中，<code>copy()</code>函数的使用格式如下：</p>

<pre><code class="language-bash">copy(destSlice, srcSlice []T)
</code></pre>

<p>其中：</p>

<ul>
<li>srcSlice: 数据来源切片</li>
<li>destSlice: 目标切片</li>
</ul>

<p>举个例子：</p>

<pre><code class="language-go">func main() {
	// copy()复制切片
	a := []int{1, 2, 3, 4, 5}
	c := make([]int, 5, 5)
	copy(c, a)     //使用copy()函数将切片a中的元素复制到切片c
	fmt.Println(a) //[1 2 3 4 5]
	fmt.Println(c) //[1 2 3 4 5]
	c[0] = 1000
	fmt.Println(a) //[1 2 3 4 5]
	fmt.Println(c) //[1000 2 3 4 5]
}
</code></pre>

<h2 id="从切片中删除元素">从切片中删除元素</h2>

<p>Go语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除元素。 代码如下：</p>

<pre><code class="language-go">func main() {
	// 从切片中删除元素
	a := []int{30, 31, 32, 33, 34, 35, 36, 37}
	// 要删除索引为2的元素
	a = append(a[:2], a[3:]...)
	fmt.Println(a) //[30 31 33 34 35 36 37]
}
</code></pre>

<p>总结一下就是：要从切片a中删除索引为<code>index</code>的元素，操作方法是<code>a = append(a[:index], a[index+1:]...)</code></p>
                        </div>

                        


                        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/08-golang/">[Golang系列]-Go基础语法之数组</a></li>
        
        <li><a href="/posts/07-golang/">[Golang系列]-Go基础语法之函数</a></li>
        
        <li><a href="/posts/06-golang/">[Golang系列]-Go基础语法之流程控制</a></li>
        
        <li><a href="/posts/05-golang/">[Golang系列]-Go基础语法之运算符</a></li>
        
        <li><a href="/posts/04-golang/">[Golang系列]-Go基础语法之基础数据类型</a></li>
        
    </ul>
</div>


                        <div class="post-meta meta-tags">
                            
                            没有标签
                            
                        </div>
                    </article>
                    
    

    
    
                </div>
            </div>
            <div id="secondary">
    <section class="widget">
        <form id="search" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="http://gitzh2017.github.io/">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="http://gitzh2017.github.io/posts/12-golang/" title="[Golang系列]-Go基础语法之错误处理">[Golang系列]-Go基础语法之错误处理</a>
    </li>
    
    <li>
        <a href="http://gitzh2017.github.io/posts/00-django/" title="00 Django">00 Django</a>
    </li>
    
    <li>
        <a href="http://gitzh2017.github.io/posts/11-golang/" title="[Golang系列]-Go基础语法之指针">[Golang系列]-Go基础语法之指针</a>
    </li>
    
    <li>
        <a href="http://gitzh2017.github.io/posts/10-golang/" title="[Golang系列]-Go基础语法之map">[Golang系列]-Go基础语法之map</a>
    </li>
    
    <li>
        <a href="http://gitzh2017.github.io/posts/09-golang/" title="[Golang系列]-Go基础语法之切片">[Golang系列]-Go基础语法之切片</a>
    </li>
    
    <li>
        <a href="http://gitzh2017.github.io/posts/08-golang/" title="[Golang系列]-Go基础语法之数组">[Golang系列]-Go基础语法之数组</a>
    </li>
    
    <li>
        <a href="http://gitzh2017.github.io/posts/07-golang/" title="[Golang系列]-Go基础语法之函数">[Golang系列]-Go基础语法之函数</a>
    </li>
    
    <li>
        <a href="http://gitzh2017.github.io/posts/06-golang/" title="[Golang系列]-Go基础语法之流程控制">[Golang系列]-Go基础语法之流程控制</a>
    </li>
    
    <li>
        <a href="http://gitzh2017.github.io/posts/05-golang/" title="[Golang系列]-Go基础语法之运算符">[Golang系列]-Go基础语法之运算符</a>
    </li>
    
    <li>
        <a href="http://gitzh2017.github.io/posts/04-golang/" title="[Golang系列]-Go基础语法之基础数据类型">[Golang系列]-Go基础语法之基础数据类型</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">分类</h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title">标签</h3>
<div class="tagcloud">
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="http://gitzh2017.github.io/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
        </div>
    </div>
</div>
<footer id="footer">
    <div class="container">
        &copy; 2019 <a href="http://gitzh2017.github.io/">凡夫俗子的博客 By 凡夫俗子</a>.
        Powered by <a rel="nofollow noreferer noopener" href="https://gohugo.io" target="_blank">Hugo</a>.
        <a href="https://www.flysnow.org/" target="_blank">Theme</a> based on <a href="https://github.com/rujews/maupassant-hugo" target="_blank">maupassant</a>.
        
    </div>
</footer>


    <script type="text/javascript">
    
    (function(){
        $("pre code").parent().addClass("line-numbers")
    }())

    window.MathJax = {
        tex2jax: {
            inlineMath: [ ['$','$'] ],
            processEscapes: true
        }
    };
    </script>
    <script type="text/javascript" src="/js/prism.js" async="true"></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src="/js/totop.js?v=0.0.0" async=""></script>






</body>
</html>
